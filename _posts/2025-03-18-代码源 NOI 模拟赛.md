---
layout: post
title: 代码源 NOI 集训
subtitle: 模拟赛
tags: OI 赛制去死
show: false
---

# [Day 1](http://oj.daimayuan.top/contest/321)

### [T1](http://oj.daimayuan.top/contest/321/problem/3013)

什么 B 题。

首先对 $p$ 从大到小排序，一定取一段前缀做。暴力 DP $f_{i,j}$ 表示前 $i$ 个做对了 $j$ 个。可以证明有值的项不会特别多（？？？），大概是 $\mathcal O(\sqrt{n\log{\epsilon^{-1}}})$ 级别的，所以暴力就过了。诗人我诗。

有一个分块 FFT 暴力，非常不牛。dls 还讲了一个很牛的分治。

考虑 `solve(l,r,F)` 表示要处理区间 $[l,r]$，然后 $[1,l-1]$ 的所有多项式乘起来是 $F$。

考虑 $[x^i]F$，如果 $i-(r-l+1)>k$，那这个一定有贡献，直接加到区间里面就行了。如果 $i+(r-l+1)<k$，那这个一定没有贡献，所以需要考虑的项只有 $[k-(r-l+1),k+(r-l+1)]$ 里面的，是 $\mathcal O(r-l+1)$ 级别的。这样用 FFT 优化多项式乘法之后就可以做到 $\mathcal O(n\log^2 n)$ 求出每一项的答案了。

### [T2](http://oj.daimayuan.top/contest/321/problem/3014)

参考炫酷原神。

首先如何判一个子序列是否：把串扔进子序列自动机里，找到尽可能往前匹配的话，每个字符 $i$ 匹配到了哪个位置 $p_i$。如果存在相邻两个 $p_i,p_{i+1}$，满足 $(p_i,p_{i+1})$ 里面出现了一个和 $p_i$ 颜色相同的数，那就一定合法。容易发现这个条件是充要的。

看上去很像什么矩乘优化。从后向前 DP，$f_{i,j,0/1}$ 表示考虑了 $[i,n]$ 这个后缀，选的第一个数颜色是 $j$（注意 $j$ 所在的位置一定是 $i$ 后面第一次出现 $a_k=j$ 的位置 $k$），是否已经合法的方案数。

转移非常麻烦的分类讨论一下：首先是 $f_{i-1,\not=a_i,0/1}$ 都可以转移到 $f_{i,\not=a_i,0/1}$，表示不选这个 $a_i$。

而如果选了 $a_i$，那就是 $f_{i-1,j,k}$ 转移到 $f_{i,a_i,k\vee(t_{a_i}<t_j)}$，$t_{x}$ 表示 $x$ 这个颜色第一次在 $[i+1,n]$ 中的出现位置。还有 $f_{i,a_i,[t_{a+i}=n+1]}$ 加一。

容易发现转移可以写成大小为 $13$ 的矩阵，并且修改一个位置最多会修改 $m+1$ 个地方的矩阵（修改位置 $x$ 前面每一个颜色的最后一次出现位置的矩阵都有可能发生变化），但是两个矩阵相乘实际上不用乘这么多项，因为 $f_{\ast,1}$ 不可能转移到 $f_{\ast,0}$，并且常数项也不会变，加上一些神秘剪枝（比如判断矩阵实际上有没有改变，线段树修改 $m$ 个位置最后只 `update` 一次），实际是能跑过的。复杂度 $\mathcal O(nD(m)+qmD(m)\log n)$。其中 $D(m)$ 表示矩阵乘法需要的时间，剪枝之后可以达到 $3m^3$ 左右。

### [T3](http://oj.daimayuan.top/contest/321/problem/3015)

遗憾离场。看上去像个分析性质题，实际上比较暴力。

首先暴力从后向前模拟，维护 $f_i$ 表示当前如果让这个人统一，需要分到 $f_i$ 个金币。显然从小到大选，复杂度是 $\mathcal O(n^2\log n)$。

核心性质是每个人分得的钱数一定不会超过 $\max(a)$（记为 $w$）。这个可以简单构造达到。

所以拿一个线段树维护 $A_{i,j}$ 表示如果当前先让他同意，需要花费 $i$ 个金币，贪婪值等于 $j$ 的点的位置集合。

处理到 $i$ 的时候，从小到大枚举金币数量，什么时候总和大于 $m$ 了或者人数合法了就停下。然后很讨厌的限制是金币相同的话编号从大到小选，所以确定了最大金币数 $k$ 后，$<k$ 的所有人都要选，然后所有 $=k$ 的人选的是一段后缀，所以在所有 $A_{k,\ast}$ 上同时进行一个线段树二分，即可找出所有的区间。

对于不选的人，金币数全部归零，然后所有人的金币数都加上各自贪婪值。这里会发生若干合并和分裂，需要线段树合并和分裂实现。这样是 $\mathcal O(na^2\log n)$ 左右。

注意到一个人清零之后，金币数就一定是他自己贪婪值的倍数，所以对于还没被清零过的数暴力处理（一个人最多被暴力处理 $256/a$ 次），这样复杂度可以优化到 $\mathcal O(n(a\log n+w(a)\log n))$，实际远远跑不满。