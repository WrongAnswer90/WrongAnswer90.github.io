---
layout: post
title: 2024 NOIP 代码源
subtitle: 模拟赛
tags: 模拟赛
---

# [Day 1](http://oj.daimayuan.top/contest/264)

有点烦。2h 只会 D 的次低档暴力。

### [T1](http://oj.daimayuan.top/contest/264/problem/2759)

答案和连续段有关，所以是一堆卡特兰数乘起来。

### [T2](http://oj.daimayuan.top/contest/264/problem/2760)

可以发现 $SG_x(i)=i\bmod {(x+1)}$。现在就是要对于每个 $x$ 求出 $\displaystyle \bigoplus_{i=1}^n a_i\bmod {(x+1)}$。

首先扔到桶里，然后考虑倍增，预处理 $f_{i,j}$ 表示 $\displaystyle \bigoplus_{i\leq k<i+2^j} t_k\times (k\bmod{(x+1)})$。然后就可以对于每个 $x$，暴力跳查询了。查询就是把长度为 $x+1$ 的段分成 $\log$ 个区间用倍增数组差，然后总查询次数是调和级数 $\mathcal O(n\log n)$ 级别，所以总复杂度是 $\mathcal O(n\log^2 n)$。

### [T3](http://oj.daimayuan.top/contest/264/problem/2761)

先枚举第一个不同位置，然后枚举这个位置填什么，限制是 $a_{fa_x}<v<a_x$。预处理 $f_i$ 表示 $i$ 子树内相对顺序的方案数。考虑所有填了的位置 $[1,i]$，每个点上会挂一些子树，子树的要求就是全部 $\geq a_x$。

值域从大到小扫一遍，初始令 $tot=0$，如果这个值没有填过则令 $tot+1$，遇到一个 $[1,i]$ 中出现过的值就乘一个 $\binom{tot}{siz-1}$，然后 $tot-siz$。这样复杂度是 $\mathcal O(n^3)$。

考虑优化，不需要枚举 $x$ 这个位置填什么，只需要做一遍差分，令 $v>a_{fa_x}$ 的方案数减去 $v>a_x$ 的方案数即可。这样就把 $v$ 分别挂在 $a_{fa_x}$ 的位置和 $a_x$ 的位置做两遍即可。还需要乘上父亲确定了但是自己没有确定的点的 $f$ 以及挂在同一个父亲上的子树的相对顺序。复杂度 $\mathcal O(n^2)$。

对于输出方案，可以先通过计数这一部分确定出 LCP，然后第一个位置填的不同。考虑新开一个数组 $b_i$ 表示 $\geq i$ 的值能用几个。初始 $b_i=n-i+1$。

这样新填了一个数就令 $b[a_{fa_i}+1,a_i]$ 全部减 $siz_i$。只需要保证 $b$ 非负。复杂度也是 $\mathcal O(n^2)$。

### [T4](http://oj.daimayuan.top/contest/264/problem/2762)

全错了。

考虑确定了一个答案 $x$ 之后如何 `chk`。做一遍前缀和，则对于操作完的数组的前缀和，要求就是 $\forall i<j,s_j-s_i\leq x$ 并且 $\forall i<n,s_{i+1}-s_i\leq a_i$。

**注意到**操作次数就是 $\sum_ia_i-s_n$，其中 $a$ 是原数组，所以需要最大化 $s_n$。这是**差分约束**的形式，就是需要连边跑最短路。

操作次数关于答案 $x$ 显然是一个分段凸函数。随着 $x$ 的减小，操作次数先 $+1$，然后 $+2$......最后 $+n$。只需要求出来具体的分段函数就能得到答案。

设 $f_i$ 表示经过 $i$ 条 $x$ 边的最短路。看成是选择 $i$ 个区间删掉使得删掉的区间和最大，这是经典反悔贪心问题，拿线段树维护最大子段和，每次选最大的段乘一个 $-1$ 即可。

求出来 $f_i$ 之后分段函数也比较好求了。复杂度是 $\mathcal O(n\log n)$。

感觉就是眼高手低，首先做不到一眼全看透。然后想到一点正解，感觉没救就不想了，然后就开始对着错误做法乱弄。说不定把思路写写，写出来就会了。

# [Day 2](http://oj.daimayuan.top/contest/267)

### [T1](http://oj.daimayuan.top/contest/267/problem/2767)

建一个图表示大小关系的限制，求一下拓扑序即可。

### [T2](http://oj.daimayuan.top/contest/267/problem/2772)

先删开头结尾相同的字符。然后剩下的串分成四部分 $A_1,A_2,A_3,A_4$，假设 $A_2+A_4$ 是选择的回文串（正反做两遍这个就考虑到了所有情况）。

先跑一遍 `manacher` 预处理每个点为回文中心的最长扩展长度 $f_i$。

假设回文中心在 $A_4$，则枚举回文中心 $i$，要求 $i-(n-i)$ 前面存在一个 $j$ 满足 $[j,n]$ 的 `border` 长度 $\geq n-i-f_i$，可以求一遍 kmp 解决。

假设回文中心在 $A_2$，还是枚举中心 $i$，要求 $j+nex_j\geq i-f_i$，其中 $nex_j$ 是 $[j,n]$ 的 `border` 长度，求满足这个的最小的 $j$。这个可以看成是每个 $j$ 都做了一个前缀 `chkmax`，也可以简单解决。

### [T3](http://oj.daimayuan.top/contest/267/problem/2770)

正数一定全选，那就是要花最小的代价走到终点。设 $f_{i,0/1}$ 表示当前走到了 $i$ 的上/下列上的最短路，可以转移到 $f_{[i-m,i_m],opt^1}$。

因为是点权最短路，所以只有第一次激活某个点才是有用的。所以不需要什么优化建图，只需要简单维护两个指针表示当前激活了两个前缀，每次向右移即可。复杂度 $\mathcal O(n\log n)$。

### [T4](http://oj.daimayuan.top/contest/267/problem/2771)

感觉我太菜了。

首先预处理 $f_i$ 表示点 $i$ 的期望深度。

$d(u,v)$ 拆成 $dep_u+dep_v-2dep_{lca(u,v)}$，前两者容易统计，考虑如何统计后者。

希望能够处理出 $g_i$ 表示以 $i$ 为 $lca$ 的点对数。但是两个点向上走，以 $i$ 为祖先的概率是不独立的。考虑一种统计方式：两个点都是任意往上走，在**第一次相遇**的位置把他们统计。

先统计 $h_j$ 表示 $i$ 是 $j$ 祖先的概率。初始令 $g_i=(1+\sum_j h_j)^2$。然后考虑每个点对在第一次相遇的位置归类，需要的是第一次相遇恰好在 $i$ 的点对，所以需要减去在其他地方相遇的点对。那就是要减去所有 $h_j^2g_j$。平方是因为有两个点，走的是两条可能不同的路径。复杂度是调和级数（？）

# [Day 3](http://oj.daimayuan.top/contest/268)

### [T1](http://oj.daimayuan.top/contest/268/problem/2763)

懒得喷。

是若干个斐波那契数乘起来，暴力记忆化搜索处理 $f_i$ 表示 $i$ 是否合法，这样可以求出来 $nex_i$ 表示 $i$ 拼的第一个斐波那契数最大是多少。

### [T2](http://oj.daimayuan.top/contest/268/problem/2764)

搞不懂。

暴力是 $\mathcal O(n\log^2 n)$。考虑一维以 $L$，第二维是 $F$，这样就是要找到 $y$ 后面 $R\geq x$ 的第一个位置状物，可以线段树上二分。这样就是一个 $\log$。

### [T3](http://oj.daimayuan.top/contest/268/problem/2765)

我傻逼。

答案是若干个段，一段内部是连续的给很多人理发，段之间不交。现在要处理从第 $i$ 个人开始，连续给 $j$ 个人理发的最大收益。

从前向后扫，每一时刻只保留 $m-1$ 个人，人多了就删去收益最小的。然后取出收益最大的人拼在后面继续加入新的人。可以拿一个堆维护，复杂度 $\mathcal O(n^2\log n)$。

正确性就是当前时刻最多就只有 $m-1$ 个人对未来有贡献。然后如果先给后来的人理了再给前面的人理发可以看成是进行了一次类似反悔的东西，在前面插入了这个人。

### [T4](http://oj.daimayuan.top/contest/268/problem/2766)

还是我傻逼。

设 $f_i$ 表示点 $i$ 的答案，则：

$$
f_i=\min(\max_{(i,j)}f_j,\min_{(i,j)}f_j+1)
$$

考虑逐层确定答案，即先确定答案为 $0$ 的，然后是为 $1$ 的......首先 $t$ 的答案为 $0$。然后假设处理到了第 $i$ 层，则能一步走到答案为 $i-1$ 的点的点答案就是 $i$。这是考虑了第二种转移。

然后考虑第一种转移，这个就是怎么走都只能走到答案 $=i$ 的点的点。可以先把答案 $<i$ 的点删掉，然后答案 $=i$ 的点的出边删掉，然后在这个图上跑 SCC，做一遍拓扑排序就行了。复杂度 $\mathcal O(n(n+m))$。