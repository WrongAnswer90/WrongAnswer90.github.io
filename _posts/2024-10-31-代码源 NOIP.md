# [Day 1](http://oj.daimayuan.top/contest/264)

有点烦。2h 只会 D 的次低档暴力。

### [T1](http://oj.daimayuan.top/contest/264/problem/2759)

答案和连续段有关，所以是一堆卡特兰数乘起来。

### [T2](http://oj.daimayuan.top/contest/264/problem/2760)

可以发现 $\text{SG}_x(i)=i\bmod {(x+1)}$。现在就是要对于每个 $x$ 求出 $\displaystyle \bigoplus_{i=1}^n a_i\bmod {(x+1)}$。

首先扔到桶里，然后考虑倍增，预处理 $f_{i,j}$ 表示 $\displaystyle \bigoplus_{i\leq k<i+2^j} t_k\times (k\bmod{(x+1)})$。然后就可以对于每个 $x$，暴力跳查询了。查询就是把长度为 $x+1$ 的段分成 $\log$ 个区间用倍增数组差，然后总查询次数是调和级数 $\mathcal O(n\log n)$ 级别，所以总复杂度是 $\mathcal O(n\log^2 n)$。

### [T3](http://oj.daimayuan.top/contest/264/problem/2761)

先枚举第一个不同位置，然后枚举这个位置填什么，限制是 $a_{fa_x}<v<a_x$。预处理 $f_i$ 表示 $i$ 子树内相对顺序的方案数。考虑所有填了的位置 $[1,i]$，每个点上会挂一些子树，子树的要求就是全部 $\geq a_x$。

值域从大到小扫一遍，初始令 $tot=0$，如果这个值没有填过则令 $tot+1$，遇到一个 $[1,i]$ 中出现过的值就乘一个 $\binom{tot}{siz-1}$，然后 $tot-siz$。这样复杂度是 $\mathcal O(n^3)$。

考虑优化，不需要枚举 $x$ 这个位置填什么，只需要做一遍差分，令 $v>a_{fa_x}$ 的方案数减去 $v>a_x$ 的方案数即可。这样就把 $v$ 分别挂在 $a_{fa_x}$ 的位置和 $a_x$ 的位置做两遍即可。复杂度 $\mathcal O(n^2)$。

对于输出方案，可以先通过计数这一部分确定出 LCP，然后第一个位置填的不同。考虑新开一个数组 $b_i$ 表示 $\geq i$ 的值能用几个。初始 $b_i=n-i+1$。

这样新填了一个数就令 $b[a_{fa_i}+1,a_i]$ 全部减 $siz_i$。只需要保证 $b$ 非负。复杂度也是 $\mathcal O(n^2)$。

### [T4](http://oj.daimayuan.top/contest/264/problem/2762)

全错了。

考虑确定了一个答案 $x$ 之后如何 `chk`。做一遍前缀和，则对于操作完的数组的前缀和，要求就是 $\forall i<j,s_j-s_i\leq x$ 并且 $\forall i<n,s_{i+1}-s_i\leq a_i$。

**注意到**操作次数就是 $\sum_ia_i-s_n$，其中 $a$ 是原数组，所以需要最大化 $s_n$。这是**差分约束**的形式，就是需要连边跑最短路。

操作次数关于答案 $x$ 显然是一个分段凸函数。随着 $x$ 的减小，操作次数先 $+1$，然后 $+2$......最后 $+n$。只需要求出来具体的分段函数就能得到答案。

设 $f_i$ 表示经过 $i$ 条 $x$ 边的最短路。看成是选择 $i$ 个区间删掉使得删掉的区间和最大，这是经典反悔贪心问题，拿线段树维护最大字段和，每次选最大的段乘一个 $-1$ 即可。

求出来 $f_i$ 之后分段函数也比较好求了。复杂度是 $\mathcal O(n\log n)$。

感觉就是眼高手低，首先做不到一眼全看透。然后想到一点正解，感觉没救就不想了，然后就开始对着错误做法乱弄。说不定把思路写写，写出来就会了。怎么改掉这种东西呢。