# [Day 1](http://oj.daimayuan.top/contest/264)

有点烦。2h 只会 D 的次低档暴力。

### [T1](http://oj.daimayuan.top/contest/264/problem/2759)

答案和连续段有关，所以是一堆卡特兰数乘起来。

### [T2](http://oj.daimayuan.top/contest/264/problem/2760)

可以发现 $\text{SG}_x(i)=i\bmod {(x+1)}$。现在就是要对于每个 $x$ 求出 $\displaystyle \bigoplus_{i=1}^n a_i\bmod {(x+1)}$。

首先扔到桶里，然后考虑倍增，预处理 $f_{i,j}$ 表示 $\displaystyle \bigoplus_{i\leq k<i+2^j} t_k\times (k\bmod{(x+1)})$。然后就可以对于每个 $x$，暴力跳查询了。查询就是把长度为 $x+1$ 的段分成 $\log$ 个区间用倍增数组差，然后总查询次数是调和级数 $\mathcal O(n\log n)$ 级别，所以总复杂度是 $\mathcal O(n\log^2 n)$。

### [T3](http://oj.daimayuan.top/contest/264/problem/2761)

先枚举第一个不同位置，然后枚举这个位置填什么，限制是 $a_{fa_x}<v<a_x$。预处理 $f_i$ 表示 $i$ 子树内相对顺序的方案数。考虑所有填了的位置 $[1,i]$，每个点上会挂一些子树，子树的要求就是全部 $\geq a_x$。

值域从大到小扫一遍，初始令 $tot=0$，如果这个值没有填过则令 $tot+1$，遇到一个 $[1,i]$ 中出现过的值就乘一个 $\binom{tot}{siz-1}$，然后 $tot-siz$。这样复杂度是 $\mathcal O(n^3)$。

考虑优化，不需要枚举 $x$ 这个位置填什么，只需要做一遍差分，令 $v>a_{fa_x}$ 的方案数减去 $v>a_x$ 的方案数即可。这样就把 $v$ 分别挂在 $a_{fa_x}$ 的位置和 $a_x$ 的位置做两遍即可。复杂度 $\mathcal O(n^2)$。

对于输出方案，可以先通过计数这一部分确定出 LCP，然后第一个位置填的不同。考虑新开一个数组 $b_i$ 表示 $\geq i$ 的值能用几个。初始 $b_i=n-i+1$。

这样新填了一个数就令 $b[a_{fa_i}+1,a_i]$ 全部减 $siz_i$。只需要保证 $b$ 非负。复杂度也是 $\mathcal O(n^2)$。

### [T4](http://oj.daimayuan.top/contest/264/problem/2762)

感觉我好菜。