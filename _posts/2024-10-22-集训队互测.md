---
layout: post
title: 2024 集训队互测
subtitle: 做题
show: true
tags: 做题
---

# [Day 1](https://qoj.ac/contest/1808)

### [T1](https://qoj.ac/contest/1808/problem/9463)

感觉能做。

首先考虑给定了一个序列如何判是否合法。如果确定了三种子序列分别的出现次数，暴力 DP 是记录 `A`,`B`,`C`,`AB`,`BC`,`CA` 的出现次数的方案是否合法。

从前向后扫 $s$ 串，如果当前出现了一个字符 `A`，他可以单独成一个新的序列，可以拼到 `C` 上，也可以拼到 `BC` 上。

感性理解就是因为三个串是循环同构的，考虑如果新成一个序列，他后面还要接 `B`,`C`，拼到 `C` 上面还需要接一个 `B`，拼到 `BC` 上面后面就没有限制了。

显然单独成串严格强于拼到 `C` 上严格强于拼到 `BC` 上。因为所有条件最终都需要满足，所以考虑先满足严格的条件一定不劣。理性理解可以通过邻项交换来证明决策包容性。

这样就有贪心：确定了三种子序列的出现次数后，新出现的字符尽量单独成段，其次尽量拼到一个字符上，再次才是拼到两个字符上。设 $x_{0/1/2}$ 表示三种字符当前出现次数，$X_{0/1/2}$ 表示三种字符的上界，可以推出序列合法的充要条件就是保证时时刻刻 $x_i-X_i\leq x_{i+2\bmod 3}$。

一个串可能有多种合法的子序列划分方式。考虑容斥，钦定一些可选方案必须满足。设 $S$ 表示钦定 $x\in S$ 个 `ABC` 需要满足，$T$ 表示钦定 $y\in T$ 个 `BCA` 需要满足，则限制可以变为：

$$
x_0-x_{\min}\leq x_2\\
x_1-y_{\min}\leq x_0\\
x_2-(n-x_{\max}-y_{\max})\leq x_1
$$

容斥系数是 $(-1)^{\lvert S\rvert+\lvert T\rvert}$。容易发现只和 $S,T$ 中的最大，最小值有关。并且考虑对于一对 $x$ 的最小，最大值 $(x,y)$，如果 $x,y$ 中间还有可选方案，则所有 $S$ 的容斥系数之和为 $0$，所以只需要考虑两个相邻的可选方案。选单独一个的容斥系数是 $1$，选相邻两个的容斥系数是 $-1$。对于 $y$ 也同理，这样只需要做 $\mathcal O(n^2)$ 次计算方案数，而计算方案数可以用一个简单的 $\mathcal O(n^3)$ DP 解决。注意常数优化。

上面的容斥也是点减边，因为合法的取值都是一段区间，但是直接发现是一段区间可能不是那么的明显（可能也比较明显，本身就是关乎最大最小值的限制）。

### [T2](https://qoj.ac/contest/1808/problem/9464)

做不了一点。

生成方式等价于 $p_i=\mathrm{popcount}(i)\bmod 2$，也等价于 $P_k=P_{k-1}+\mathrm{flip}(P_{k-1})$，其中 $P_k$ 表示生成 $k$ 步的 $P$ 序列，加号是字符串拼接，$\mathrm{flip}$ 是翻转。

首先有 $\mathrm{flip}(S_i)=\mathrm{rev}(S_i)$，可以简单归纳证明。

> 性质 $1$：$01$ 序列 $S$ 合法的充要条件是存在一个位置 $p$，使得 $\mathrm{rev}(S[1\dots k])$ 是 $P$ 串或者 $\mathrm{flip}(P)$ 的前缀，$S[k+1\dots n]$ 也是 $P$ 串或者 $\mathrm{filp}(P)$ 的前缀。

必要性显然。充分性：对于一个充分长的 $S_k$，设 $S'_k$ 表示 $\mathrm{rev}(S_k)$，则有以下结构在 $P$ 中存在：

$$
S_k,S'_k,S'_k,S_k,S'_k,S_k,S_k,S'_k
$$

取第一个和第二个，前后缀分别是 $P'$ 和 $P'$。取第二个和第三个，前后缀分别是 $P$ 和 $P'$。取第四个和第五个，前后缀分别是 $P$ 和 $P$。取第五个和第六个，前后缀分别是 $P'$ 和 $P$。所以上述条件是序列合法的充要条件。

对原序列直接通过这个进行计数会有问题，因为一个序列可能会有多个合法的拆分方式。考虑如何处理算重的情况。下面开始展示魔法了。。。

> 性质 $2$：串 $S$ 如果既是 $P$ 的前缀，$\mathrm{rev}(S)$ 是 $P'$ 的前缀，则 $S$ 的长度为 $2$ 的次幂。

这谁想的到啊。。

设 $w(i)$ 表示 $i$ 中 $1$ 的个数的奇偶性。反证法，假设存在 $\lvert S\rvert \not = 2^k$，首先有 $S_i=x\oplus w(i)=y\oplus w(\lvert S\rvert -1-i)$，其中 $x,y\in\{0,1\}$。所以 $\forall i\in[0,\lvert S\rvert-1],w(i)\oplus w(\lvert S\rvert -1-i)=w(\lvert S\rvert-1)$。

因为 $\lvert S\rvert-1\not = 2^k-1$，所以一定存在一个位置满足 $\mathrm{bit}_k(\lvert S\rvert-1)=0,\mathrm{bit}_{k+1}(\lvert S\rvert-1)=1$。

所以 $w(\lvert S\rvert -1)=w(2^k)\oplus w(\lvert S\rvert -1-2^k)=1\oplus w(\lvert S\rvert -1)$（考虑 $\lvert S\rvert -1$ 消去了一个 $1$，又出现了一个 $1$）。与原命题不符，假设不成立。

> 性质 $3$：一个串最多有两种拆分方式。

首先考虑有两种拆分方式，假设 $S$ 可以被拆成 $[A+B][C]$ 和 $[A][B+C]$，因为 $B$ 和 $\mathrm{rev}(B)$ 同时是 $P$ 或 $P'$ 的前缀，所以 $\lvert B\rvert =2^k$。

反证法，假设一个串有三种拆分方式，$[A+B+C][D],[A+B][C+D],[A][B+C+D]$，则 $\lvert B\rvert ,\lvert C\rvert ,\lvert B+C\rvert $ 都应当为 $2$ 的次幂，所以 $\lvert B\rvert =\lvert C\rvert$。

观察 $P$ 的生成方式，可以得到 $C_0=B_0\oplus 1,D_0=C_0\oplus 1,D_0=B_0\oplus 1$，假设不成立。

现在要算的就是所有拆分方式的串数量之和减去有两种拆分方式的串。

设 $pre_{i,0/1},nex_{i,0/1}$ 表示从 $i$ 开始和 $P$ 与 $P'$ 进行匹配最远向前，向后匹配到哪里。这个可以倍增预处理。这样枚举位置 $i$，算拆分方式的串数量之和可以看成一个二维矩形加。

对于有两种拆分方式的串，先枚举 $2^k$ 的区间长度以及区间的位置 $[l,r]$。考虑长度为 $2^k$ 的串 $S$，现在要求一个 $T$，满足 $S$ 是 $T$ 的前缀，并且 $T$ 和删去前缀 $S$ 的 $T$ 都在 $P$ 或 $P'$ 中出现。$S$ 在 $P$ 中的出现应当是 $S,S',S'\dots$ 这样 $T$ 删掉 $S$ 前缀之后最多还有 $\lvert S\rvert$ 的合法长度，所以只需要求 $\max(pre_r,l-2^k)$ 和 $\min(nex_l,r+2^k)$ 作为矩形加的左右端点即可。

这样问题转化为了有 $\mathcal O(n\log n)$ 次矩形加，多次查询：

$$\sum_{l\leq l'\leq r'\leq r}c_{l',r'}p_{l,l'-1}p_{r'+1,r}$$

$p$ 的贡献就是问号带来的方案数，可以差分处理，所以可以转化成矩形 $a_{i,j}\overset +\leftarrow b_{i,j}$，矩形求和 $b_{i,j}$，可以用线段树维护矩阵解决，复杂度 $\mathcal O(n\log^2 n+q\log n)$。

### [T3](https://qoj.ac/contest/1808/problem/9465)

限制是对于一列需要先填完所有 $A_{i,j}=0$ 的位置，才能填 $A_{i,j}=1$ 的位置。对于一行则相反。

如果一步中填了 $B_{i,j}$，如果 $A_{i,j}=1$，也需要填同一列中 $A_{i,j}=0$ 的位置。如果 $A_{i,j}=0$ 则需要填同一行中 $A_{i,j}=1$ 的位置。这样连边之后就是求图中 SCC 的数量。

