---
layout: post
title: 数据结构
subtitle: 讲题
tags: /shq
show: false
---

### [QOJ9918 Master of Both VI](https://qoj.ac/problem/9918)

比较简单。一眼 DDP，用 min+ 矩乘维护攻击。

可以离线用下标为操作序列线段树合并求出每个点的操作序列，然后查询就是线段树二分一下。

### [CF1750H Binary Forces](https://www.luogu.com.cn/problem/CF1750H)

非常困难。但是似乎不太是 DS。

首先考虑对于每个左端点 $l$ 求出所有合法的右端点。假设 $[l,r]$ 合法，若 $s_r=1$ 则 $\forall r<d\leq r+(r-l+1),[l,d]$ 合法。然后如果 $[l,r]$ 合法，$s_r=1,s_{r+1}=0$，后面一段极长 $0$ 连续段 $[r+1,d]$ 满足 $d>r+(r-l+1)$，那就会变成不合法。接下来想要合法，就需要找到 $d$ 后面的一段最短的合法区间，满足其长度大于等于 $d-r$ 才能再次变成合法。

总结一下上述过程：若当前 $[l,r]$ 合法，则找到一个最大的 $d$ 满足 $d\leq r+(r-l+1)\wedge s_d=1$，令 $r=d$，继续合法。若找不到，则变为不合法状态，令 $r$ 变成当前 $0$ 连续段末尾，找到以 $r+1$ 开头的，长度第一个大于等于 $d-l+1$ 并且结尾也是 $1$ 的合法段，重复以上过程，就能找到所有结尾是 $1$ 的串，这形成了 $\log$ 个区间。

正反做两遍之后，考虑统计答案。考虑对于一个串 $S$，其中的最长 $0$ 连续段 $[l,r]$，$s_{l-1}=s_{r+1}=1$，能把这个连续段吞掉是这个串合法的充要条件。极长 $0$ 连续段的数量是 $\mathcal O(n)$ 的（包括所有 $0$ 连续段以及他们的前后缀），然后就可以随便扫描线统计答案了，复杂度 $\mathcal O(n\log^2 n)$。

### [CF1852F Panda Meetups](https://www.luogu.com.cn/problem/CF1852F)

考虑二维平面上，一个红点 $(x,t)$，可以匹配他上方一个锥形区域内的蓝点。最大匹配数可以转化为最大独立集。

最大独立集就是从左到有划一条线，线上方的红点有贡献，下方的蓝点有贡献。横坐标加一的时候，纵坐标至多变化 $1$。

考虑 DP，设 $f_{i,j}$ 表示横坐标走到了 $i$，纵坐标在 $j$ 的最大选点数。一个点的贡献是区间加。

维护其差分，点的贡献变成单点修改，正的差分会向左平移一个，负的会向右平移，两个撞在一起会加在一起，直接拿一个堆状物维护即可。

### [CF1942H Farmer John's Favorite Intern](https://www.luogu.com.cn/problem/CF1942H)

非常困难。

考虑连边的关系，一个生长和一个收割操作能匹配的充要条件是互为祖先后代关系。

还是转成最大独立集。选了一个后代的 $b$ 就不能选祖先上的生长操作，选了一个收割就不能选后代的所有。然后分类讨论一万种情况就能转移了，还是动态 DP。