---
layout: post
title: 2024.10.11 图论
subtitle: 做题
tags: 做题
---

### [CF1209F Koala and Notebook](https://www.luogu.com.cn/problem/CF1209F)

首先最小化位数，然后最小化字典序。

每个边拆边成一位数之后，建分层图，每层依次处理，用类似求 SA 的方法，给每层的点重标号。

### [CF325C Monsters and Diamonds](https://www.luogu.com.cn/problem/CF325C)

判 `-1 -1`：一个点存在操作全变成 $-1$ 那它自己就可以消完，做一个类似拓扑排序的东西（如果一个规则的后继点全部确定了难就把这个规则的出发点扔进队列），如果一个点存在操作方式使得所有出边都能消完那他就能消完。

最小值：把上述过程改成 `dij`。仍然是在一个规则的所有指向点全部确定的时候才扔进堆里。

最大值是无穷：如果一个点能走到环上那就是能取到无限大（因为每个转化方式至少带来一个钻石）。还是做一遍拓扑排序，最后没删掉的点都能取到无限大。（可以记忆化搜索但是不好写？）

最大值不是无穷：走不到环上的话可以拓扑排序之后求最大值。

### [CF1804F Approximate Diameter](https://www.luogu.com.cn/problem/CF1804F)

好难。。。

首先考虑静态怎么做。因为是小于等于两倍的真实值，基于这个两倍，考虑找一个中转点：选一个点，求出来其他所有点到他举例的最大值 $T$（即偏心距），则真实值在 $T$ 和 $2T$ 之间。

现在还有加边。考虑这个 $\frac 1 2$ 怎么用。考虑加边之后直径一定会减小，而减小后如果仍然 $\geq \frac T 2$，那回答 $T$ 仍然是对的。

所以需要找到下一个时刻使得一号点偏心距 $<\frac T 2$ 的加边，可以进行二分。找到一个点之后 $T$ 会变成 $\frac T 2$，所以最多只会二分 $\log$ 次，复杂度是 $\mathcal O(n\log^2 n)$。

另一道题：QOJ9231

### [CF1515F Phoenix and Earthquake](https://www.luogu.com.cn/problem/CF1515F)

首先猜只取一棵树就是对的。然后因为最后值要 $\geq 0$，所以 $\sum_i a_i\geq (n-1)x$。这样一定存在一条边使得两端点权和 $\geq x$。

如果最大点权 $\geq x$ 那就可以合并最大值和任意一个点。而如果最大点权 $<x$，则所有点的点权都 $<x$，感觉上大家就都非常的大。结论是最大点权加上他旁边任意一个邻居就是可以的，因为如果他旁边的一条边 $<x$，然后剩下的 $n-2$ 个点点权也都 $<x$，总和就一定 $<(n-1)x$。

所以可以合并最大值和他任意一个邻居。启发式合并维护边即可。

### [CF1515G Phoenix and Odometers](https://www.luogu.com.cn/problem/CF1515G)

因为要走回自己所以求 SCC。因为 $\bmod\;t$ 意义下所以可以走 $t$ 遍把一个东西消掉，所以任意的环都可以走任意次。

求 SCC 内所有环长的 $\gcd$：dfs 的时候标一下在 dfs 树上的深度，然后对于所有非树边 $(u,v)$，可以贡献一个 $d_u-d_v+w$。

### [CF1889D Game of Stacks](https://www.luogu.com.cn/problem/CF1889D)

变态。。。考虑 $k=1$ 怎么做，显然是直接建图，找到每个点能走到的第一个在环上的点即可。

对于 $k$ 更大的情况，考虑栈顶形成的环，可以给他全删了全删了全删了。然后这样不断地删删删删删，直到没有环。

LCT 维护环太不牛了。

考虑 **BFS**，找到了返祖边就回溯，然后就对了。需要加当前弧优化。

### [CF1578K Kingdom of Islands](https://www.luogu.com.cn/problem/CF1578K)

感觉挺唐。删边看成强制某个点不选，可以 $2^k$ 枚举删哪个点。

加边则也可以 $2^k$ 枚举是否加进最大团里面。这样如果一个颜色块内加的边没有构成团则不合法。有加边就是构成的团的大小，没有加边的话，如果没有被删空那就还有 $1$ 的贡献，复杂度 $\mathcal O(n+k2^k)$，实现的好一点可以 $\mathcal O(2^k)$。

### [CF1534F2 Falling Sand (Hard Version)](https://www.luogu.com.cn/problem/CF1534F2)

所有沙子都要掉下来的话，连边，缩点，操作所有入度为 $0$ 的连通块。

首先连边的方式：一个沙子向下遇到第一个同列的连边，左右相邻两列的第一个连边，还有他上面和他相邻的如果有也连边。

然后**注意到**每一列上面的第 $a_i$ 个需要落下来。

感受一下，这是平面图。然后入度为零的东西横坐标一定不交，用你的感受给他排一下序。然后感受一下，就能感受到这是一段区间（类似 NOIP2010 引水入城），然后这样就能直接贪心了！

### [CF1654G Snowy Mountain](https://www.luogu.com.cn/problem/CF1654G)

完蛋了不会最最基础的处理手段了。

首先一个点周围的高度不可能跟他全都相同（除非是这个点就是关键点）。考虑从点 $u$ 开始走，如果直接顺着走到关键点停下，则会浪费动能。正确的走法是走到某一个相邻两个高度相同的点之后，假设当前剩下的动能是 $E$，反复横跳走 $E$ 步，然后走到关键点。容易发现如果走到高度为 $h_v$ 的点开始反复横跳，就浪费了 $h_v$ 的动能。所以问题转化为对于每一个点 $u$，找到他能走到的高度最低的点 $v$，使得 $v$ 旁边有和 $v$ 高度相同的点。

考虑点分治，在当前分治中心开始向下 dfs 一遍求出来 $f_i$ 表示从分治重心开始走，走到点 $i$ 需要的最小动能。然后再 dfs 一遍求出 $g_i$ 表示从 $i$ 走到分治重心能获得多少动能。因为 $f,g$ 的值域是当前连通块大小，所以可以直接开桶记。而且因为是求最大值，所以不用担心同一子树自己贡献到自己的。

### [CF1949J Amanda the Amoeba](https://www.luogu.com.cn/problem/CF1949J)

感觉挺不难的。

先找一条路径走到目标状态的一个点，然后以这个点为基础向周围扩就行了，每次选不在**当前点和目标状态的交的连通块**里的非割点删掉就行了。复杂度不重要。

### [CF325E The Red Button](https://www.luogu.com.cn/problem/CF325E)

$n$ 是奇数无解，因为 $\frac{n-1}{2}$ 向 $0$ 和 $n-1$ 有连边，然后 $0$ 和 $n-1$ 的另一条入编是自环。

因为 $i$ 和 $i+\frac n 2$ 的两条出边相同，所以先随便弄出来若干条环，然后如果 $i$ 和 $i+\frac n 2$ 不在一个连通块里就交换两个出边合并即可。

### [CF1491G Switch and Flip](https://www.luogu.com.cn/problem/CF1491G)

魔怔。

找出来置换环，**手玩**得到可以用 $x+1$ 步把一个长度为 $x$ 的环弄对。但是步数限制的非常紧。

考虑同时对两个环进行操作，也可以玩出来用 $x+y$ 步把两个长度为 $x$ 和 $y$ 的环同时拆开。

### [CF1698F Equal Reversal](https://www.luogu.com.cn/problem/CF1698F)

考虑操作是在干什么，连边 $a_i$ 和 $a_{i+1}$，这样图是一个欧拉路，然后就是要求 $a$ 和 $b$ 走出来的图是一样的。操作本质上就是在选欧拉路不同的走法。

考虑一位一位的确定：确定第 $k$ 位的时候，先找到后面两个相邻的，颜色分别为 $a_k,a_{k-1}$ 的两位。分类讨论一下：

如果出现次序是 $(a_k,a_{k-1})$，那就直接做完了，把 $a_k$ 直接转过来。

如果出现次序是 $(a_{k-1},a_k)$，那需要找到一个一段在左边，一段在右边的颜色，然后操作一下，然后再把 $a_k$ 转过去。如何证明一定能找到？考虑原图是存在欧拉路的图，$a_k$ 如果是在最后的一小段那第二个序列就不合法了。复杂度不重要。