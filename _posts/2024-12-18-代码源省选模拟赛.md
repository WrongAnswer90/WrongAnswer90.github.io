---
layout: post
title: 代码源省选模拟赛
subtitle: 模拟赛
tags: /shui
show: false
---

# [Day 3](http://oj.daimayuan.top/contest/286)

唐。

A 样例挂了，不知道暴力写没写对，不想修成正解。

B 不会。

C 冲了一整场，过了大样例，少判了个东西挂成 $30$。但是 C 好像仍然只有我一个人有分/jy。

### [T1](http://oj.daimayuan.top/contest/286/problem/2863)

弱智大模拟。维护连续段，然后稍微解一下 $\max$ 和 $\min$ 就可以只做 $\mathcal O(1)$ 个时刻的 chkmax。

### [T2](http://oj.daimayuan.top/contest/286/problem/2864)

抽象计数。

考虑差分？可能只是便于思考。给石头剪刀布标上 $012$，差分之后可以发现结构很简单。是不是直接对着他这个东西摁观察也能观察出来啊？

注意到差分之后 $-1$ 位置不变，$1$ 左移一位，如果和 $-1$ 重合就变成 $0$，$0$ 也不变。可以对这个摁 DP。

### [T3](http://oj.daimayuan.top/contest/286/problem/2865)

先考虑 $n=2d-1$ 的部分分。考虑只操作 $n$ 次，随机枚举操作顺序然后高斯消元解一下方程就能得到构造。操作顺序是 $[1,n],[2,n+1]\dots [n,2n-1],[n-1,2n-2]\dots[1,n]$。

对于 $n>2d-1$，可以不断把最后一个修对然后变成 $n-1$ 的问题，最终还是 $n=2d-1$。

对于 $n<2d-1$，中间的部分一定同时被操作，所以也可以只保留一个变成 $n=2d-1$ 的问题。

# [Day 4](http://oj.daimayuan.top/contest/287)

### [T1](http://oj.daimayuan.top/contest/287/problem/2866)

纯傻逼。哈夫曼树高只有 $80$ 左右，随便判一个匹配的东西就行了，但是写丑了导致只有 $80$。

### [T2](http://oj.daimayuan.top/contest/287/problem/2868)

非常套路。首先拆组合意义表示选 $2$ 条边。设 $F_i(x)$ 表示从 $i$ 走到 $fa_i$ 的生成函数，$[x^0]$ 表示没选边，$[x^1]$ 表示选了一条边，$[x^2]$ 表示选了两条边。走过一条边就乘一个 $(1+x)$，转移是 $F(x)=(1+x)(1+\sum(F_{son}(x)+F(x)))/deg$，化简一下就是 $F(x)=\frac{(1+x)(1+\sum F_{son}(x))}{d-(d-1)(1+x)}$，暴力求逆就行了。然后一遍换根可以求出从 $fa_i$ 走到 $i$ 的，然后就做完了。

### [T3](http://oj.daimayuan.top/contest/287/problem/2867)

非常牛的题，再说。

# [Day 5](http://oj.daimayuan.top/contest/288)

### [T1](http://oj.daimayuan.top/contest/288/problem/2882)

难。

$50$ 分是二进制分组，询问次数是 $2\log n$。

给每个点标一个恰好有 $7$ 个 $1$ 的 $14$ 位二进制数，每一位上的 $1$ 向 $0$ 贡献一遍就行了，因为没有子集关系所以是对的。

### [T2](http://oj.daimayuan.top/contest/288/problem/2883)

唐题。

先树剖，考虑编一个标号顺序。到一个点的时候，如果他是链头，就把整条链标上。然后 bfs 遍历距离他小于等于 $3$ 的所有点，给没有标号的标上号，这里 bfs 需要先把重儿子进队，然后再所有轻儿子进队（反过来也行），然后递归做。

性质很好：重链除了最上面三个点连续；子树除了重链和最高三层连续；一个点子树内距离他 $=k(k\leq 3)$ 的所有点，和他不在一条重链上的连续；这样就可以动态维护点权了。

对于一次询问，答案不超过 $3$，然后瞎判一下就行了，需要一个线段树上二分。

### [T3](http://oj.daimayuan.top/contest/288/problem/2884)

$2^nn^2$ 很简单：一行一行的填，可以状压不同等价的列的最后一个字符，每次是一个 $0$ 或 $1$ 变成 $01$ 或 $0$ 或 $1$，要求第一个变的位置必须是 $0$ 变 $1$ 或 $0$ 变 $01$。状态总数是 $2^nn$ 的，转移类似插头 DP 可以做到 $\mathcal O(1)$。最后一个组合数算一下就行了。

正解挺厉害的还是。考虑第一个字符，如果他从 $0$ 变成了 $01$ 或 $1$，则这一行的第二个及之后的字符都是自由的。以这个为阶段 DP。

设 $f_{t,i,j,0/1/01}$ 表示当前有一个长度为 $i$ 的串，经过了 $t$ 次分裂操作之后变成了长度为 $j$ 的，其中第一个字符在第一次操作后变成了 $0/1/01$，并且整体合法的方案数。注意这个定义非常神秘。他的第一行是任意填的，即如果要使用 $f_{{*},{*},{*},1}$ 和 $f_{{*},{*},{*},01}$ 时需要保证第一个字符之前已经合法或者第一个字符是 $0$，使用 $f_{{*},{*},{*},0}$ 时需要保证第一个字符之前已经合法。

首先对于 $f_{t,i,j,1}$，第一个字符从 $0$ 变成 $1$ 的话，第二个及之后的字符可以任意分裂。那就是 $\sum f_{t,i-1,j-1,*}$。

对于 $f_{t,i,j,0}$，第一个字符会在某个时刻从 $0$ 变成 $01$ 或 $1$。枚举时刻 $x$ 以及串在这个时刻的串长 $y$。在这个时刻之前方案数为 $f_{x,i-1,y-1,0/1/01}$，这个时刻之后为 $f_{t-x,y,j,1/01}$。

对于 $f_{t,i,j,01}$，还是考虑第一个字符什么时候发生变化，还是枚举 $x,y$，在这个时刻之前方案数为 $f_{x,i,y,01}$，这个时刻之后为 $f_{t-x,y,j,1/01}$。

初值 $f_{0,i,i,1}=1$。复杂度 $\mathcal O(n^5)$。

# [Day 6](http://oj.daimayuan.top/contest/290)

### [T1](http://oj.daimayuan.top/contest/288/problem/2884)

从后向前直接贪心就是对的。拿个数据结构维护一下就行了。

### [T2](http://oj.daimayuan.top/contest/290/problem/2889)

挺深刻的。

看成是一个链上，要挂若干个点，最小化直径。

类似最小直径生成树的套路，枚举中心所在位置，最小化到他的点的最大值的最小值。如果落在边上是一个单调栈之类的东西。

### [T3](http://oj.daimayuan.top/contest/290/problem/2890)

首先考虑 $AB$ 性质。对于序列的最后一个 $A$，其在操作序列中一定是相邻的 $AC$。把这个东西插到前面的位置里有 $2b-1$ 中方案。归纳，答案是 $(2b-1)!!$。$A$ 性质也是一样的。

太难了，以后再补。

# [day 7](http://oj.daimayuan.top/contest/292)

### [T1](http://oj.daimayuan.top/contest/292/problem/2885)

贡献不大好拆。考虑边分树找边。把所有边权为 $0$ 的并起来之后，剩下的只需要连前驱和后继跑 kruskal 就行了？

一开始写的是 boruvka，但是跑不动啊。kruskal 的正确性不大会证啊。

### [T2](http://oj.daimayuan.top/contest/292/problem/2880)

太变态了这题。

首先如果确定了选哪些菜以及他们的 $a$，可以通过邻项交换证明，按照 $b$ 从大到小排序就是最优的：设有 $(a_1,b_1)$ 和 $(a_2,b_2)$，前者排在前面的条件是 $\max(b_1,a_1+b_2)<\max(b_2,a_2+b_1)$。整理得 $\min(b_2,b_1-a_1)>\min(b_1,b_2-a_2)$。显然等价于 $b_1>b_2$。

然后考虑如果给定了所有的 $a$，要在其中选 $k$ 个的最小代价。就是要最小化 $\max_i(\sum_{j=1}^i a_j+b_i)$。从后向前做，所以按照 $b$ 从小到大排序，$f_{i,j}$ 表示考虑了 $[1,i]$，一共选了 $j$ 个菜，此时的最大值是多少。转移是 $f_{i,j}=\min(f_{i-1,j},\max(f_{i-1,j-1},b_i)+a_i)$。

这个东西看上去不好做，但是如果去掉了 $b$ 他就是凸的，所以其实他是有一些凸的感觉的。考虑算到了 $i$，对于所有 $\leq b_i$ 的 $f$，他以后就永远固定是这个值了，因为第二种转移以后肯定都大于 $b_i$。所以上面的 DP 等价于在做这样一件事：维护一个小根堆，每次加入 $a_i$，不断弹出值。使得弹出的和成为小于等于 $b_i$ 的最大值，**然后把堆顶 $top$ 修改为 $top-(b_i-sum)$，$sum$ 修改为 $b_i$。**

下面的计数感觉想了好久才懂啊。首先暴力就是压下来一整个堆的结构还有记录一下弹出的值的和。设 $f_{i,j,l,r,s}$ 表示考虑了 $i$ 个数，选了 $j$ 个，钦定以后小于 $l$ 的需要加进来，$>r$ 的不能加进来。对于当前的 $b$，如果 $s<b<s+r$，那说明 $r$ 以后没有被加入，修改了之后 $r+s-b$ 没有被加入。

如果 $s-l<b<s$，那说明 $l$ 加入了，即以后的某个时刻 $b-(s-l)$ 加入了，那后面小于 $b-(s-l)$ 的都需要被加入。妈的太神秘了，就这样理解吧。

### [T3](http://oj.daimayuan.top/contest/292/problem/2881)

数论题滚蛋。

# [Day 8](http://oj.daimayuan.top/contest/293)

有傻逼 A 挂了。

### [T1](http://oj.daimayuan.top/contest/293/problem/2886)

枚举 $y$，选的一定是最小的 $k$ 个 $x$，扫 $y$ 的时候线段树维护即可。

### [T2](http://oj.daimayuan.top/contest/293/problem/2887)

挺唐的感觉。

先判掉不合法。找到区间 $mx$，小于 $mx$ 的数若有 $low$ 个，大于的数有 $up$ 个。

考虑 $low=0$：填相对顺序。$f_{i,j}$ 表示填了 $i$ 个数，当前有 $j$ 个空可以填。可以转移到 $f_{i+1,k\leq j+1}$。画一下：

![image.png](https://s2.loli.net/2025/01/02/lnoideyBUTh4wLm.png)

拉直之后可以看出是格路计数，反射容斥一下可以得到答案是 $\binom{2up}{up}-\binom{2up}{up-1}$。

如果有了 $low$，一旦 $f_{i,j}$ 转移到了 $k\not= j+1$，那 $low$ 就全不能填了。而且 $low$ 内部一定得从小到大填。那枚举 $up$ 一开始走的一个极长链 $i$，方案数是 $(\binom{2up-i}{up}-\binom{2up-i}{up-1-i})\binom{i+low-1}{low-1}$。拆开之后可以组合恒等式 $\mathcal O(1)$ 算。

### [T3](http://oj.daimayuan.top/contest/293/problem/2896)

考虑倒着做。列生成函数：

$$
\begin{aligned}
F_1(x)&=x^B\\
F_i(x)&=F'_{i-1}(x)+xF_{i-1}(x)\\
ans&=[x^A]F_n(x)\\
G_i(x)&=F_i(x)e^{x^2/2}\\
G_1(x)&=x^B e^{x^2/2}\\
G_i'(x)&=F_i'(x)e^{x^2/2}+xF_i(x)e^{x^2/2}\\
        &=G_{i+1}(x)\\
G_n(x)&=(x^Be^{x^2/2})^{(n-1)}\\
F_n(x)&=e^{-x^2/2}(x^Be^{x^2/2})^{(n-1)}\\
\end{aligned}
$$

暴力求就行了。或者有个什么组合意义，就是每次可以选择加球（从小到大的标号加），或者选任意一个球取走。

# [Day 9](http://oj.daimayuan.top/contest/295)

没打 T3 暴力，被暴力老哥极限反杀。

### [T1](http://oj.daimayuan.top/contest/295/problem/2924)

暴力 DP 是维护 `vector<pii>` $f_{i,j}$ 表示 $i$ 子树内用了 $j$ 个块，pair 记的是当前所在块的大小和已经确定的块的平方和。

和一个子树合并了之后，按照 $(fi,se)$ 做一个偏序，发现不是很能过。按照 $(fi,fi\times fi+se)$ 做偏序并只保留前 $100$ 个就过了？？？

### [T2](http://oj.daimayuan.top/contest/295/problem/2922)

你怎么知道我双 $\log$ 草过去了并成为了赛时唯一通过？/kx

考虑拆贡献，对于第 $i$ 行的点，由 Lucas 定理得，最后一行有 $2^{\text{count}(i)}$ 个点对他有贡献。再枚举是第 $j$ 位做的贡献。预处理 $t_x$ 表示 $\text{count}(n-i)=x$ 的 $i$ 之和。

其余点的 GF 显然是 $\frac{1}{1-x}$，列一下这 $2^{\text{count}(i)}$ 个点每个点的 GF，你先要求第 $j$ 位上全都是 $0$：

$$
\begin{aligned}
F_0(x)&=\frac{1-x^{2^j}+x^{2\times 2^j}-x^{3\times 2^j}\dots}{1-x}=\frac{1}{(1-x)(1+2^jx)}\\
F(x)&=F_0^{2^i}(x)(\frac{1}{1-x})^{n-2^i}=(\frac{1}{1-x})^n(\frac{1}{1+2^jx})^{2^i}
\end{aligned}
$$

再考虑怎么统计答案，是一个组合数奇数位求和的形式：

$$
\begin{aligned}
&[x^m]\sum_{k\equiv 1\pmod 2}\binom{2^i}{k}x^{k2^j}\times t_i2^jF(x)\\
=&[x^m]\frac{(1+x^{2^j})^{2^i}-(1-x^{2^j})^{2^i}}{2}\times t_i2^jF(x)\\
=&\frac{1}{2}[x^m]((\frac{1}{1-x})^nt_i2^j-(\frac{1-2^jx}{1+2^jx})^{2^i})\\
=&\frac{1}{2}[x^m](\frac{1}{1-x})^nt_i2^j(1-(\frac{1-2^jx}{1+2^jx})^{2^i})
\end{aligned}
$$

后面一坨只需要对于所有 $i$ 求出 $\displaystyle (\frac{1-x}{1+x})^{2^i}$。暴力做 FFT 就过了，但是存在线性做法。

$$
\begin{aligned}
G(x)&=(1-x)^{a}(1+x)^{b}\\
G'(x)&=-a(1-x)^{a-1}(1+x)^{b}+b(1-x)^{a}(1+x)^{b-1}\\
(1-x)(1+x)G'(x)&=(-a(1+x)+b(1-x))G(x)\\
(n+1)g_{n+1}-(n-1)g_{n-1}&=(b-a)g_n+(a-b)g_{n-1}
\end{aligned}
$$

递推就行了。最后 $\frac{1}{(1-x)^n}$ 一起乘，复杂度就是 $\mathcal O(m(\log n+\log m))$。

### [T3](http://oj.daimayuan.top/contest/295/problem/2923)

不会做喵。太难了喵。但是分治好像比较容易理解。

# [Day 10](http://oj.daimayuan.top/contest/296)

挂了 $10$ 分，但是还是登顶了。

### [T1](http://oj.daimayuan.top/contest/296/problem/2926)

拍成序列，条件等价于一个区间有序，做完了。

### [T2](http://oj.daimayuan.top/contest/296/problem/2925)

首先有暴力状压 DP。然后考虑当前 DP 到了 $i$，后面有 $n-i$ 个数，有 $n-i+1$ 个间隔，只需要记录每个间隔里有多少数即可。复杂度大概是 $3^{\frac{n}{3}}\text{poly(n)}$。

### [T3](http://oj.daimayuan.top/contest/296/problem/2927)

好难。

# [Day 11](http://oj.daimayuan.top/contest/305)

### [T1](http://oj.daimayuan.top/contest/305/problem/2974)

喜欢保龄。

显然是 dp of dp 状压 LDS 的 DP 数组。对于一个状态 $S$，如果在序列末尾加入一个数字 $x$，就是把 $\leq x$ 的第一个 $1$ 抹除，然后把第 $x$ 位设成 $1$。

注意到如果 $x\in S$ 那就不变。设 $f_{S}$ 表示 $S$ 集合到达的最远的 $i$，需要找到 $f_S$ 后面第一个位置，满足 $a_i$ 和 $a_{i+1}$ 都不在 $S$ 内部。可以记录 $nex_{i,j,k}$ 表示 $i$ 后面第一个出现 $j,k$ 的位置，但是空间爆了。所以定长分块，按照 $a^2$ 大小分块，块内暴力扫一遍检查有没有连续两次出现不合法位置，块外用刚刚的方法记录数组即可。时间复杂度 $\mathcal O(n+2^aa^2)$，空间 $\mathcal O(n+2^a)$。

### [T2](http://oj.daimayuan.top/contest/305/problem/2975)

喜欢折半。

经过一些推导可以得到，答案就是，对于每条边考虑经过他的所有路径，设其长度从小到大是，$a_1,a_2\dots a_k$，则答案是 $\max_i\{a_i+k-i+1\}$。线段树合并维护这个东西即可。

### [T3](http://oj.daimayuan.top/contest/305/problem/2976)

# [Day 12](http://oj.daimayuan.top/contest/311)

### [T1](http://oj.daimayuan.top/contest/311/problem/2979)

喜欢保龄。

考虑选出性价比最大，即 $b_i/a_i$ 最大的 $(a_0,b_0)$。可以证明除了这一对外，最多选 $a_0$ 个对。证明方式是抽屉原理，考虑把除了这个的对排成一排，对 $a$ 做前缀和，如果有超过 $a_0$ 个对那就一定有一段 $a$ 的和是 $a_0$ 的倍数，可以替换。所以可以 DP 出 $f_{i,j}$ 表示 $a$ 的和最多是 $i$，$b$ 的和最大是多少。

对于 $x$ 比较小可以暴力，对于 $x>a_0\times maxa$，前面的 $a_0\times maxa$ 个对的贡献可以凸包统计。对于更大的一定有 $f_x=f_{x-a_0}+b_0$，这部分只有 $a_0$ 个，可以解一个均值不等式求出。

### [T2](http://oj.daimayuan.top/contest/311/problem/2978)

喜欢保龄。

通过牛鬼蛇神的搜索搜出操作，让一个点的度数变成 $n-1$ 即可。

### [T3](http://oj.daimayuan.top/contest/311/problem/2980)

喜欢保龄。

考虑一次操作，对于一个 $x$，找到一次操作后，谁会变成 $x$，记为 $f_x$。要求的就是 $f^d_x$。

先删去 $[1,a_1-1]$。然后按照 $1$ 分块，遇到一个 $p$ 的时候，令块长加一。则操作就是，记录一个 $pos$，初始为其所在块内 $x$ 是第几个位置。向后跳的时候，找到下一个块中除了 $p$ 以外的第 $x$ 个空位，并更新 $pos$。

最终所在块是好求的，要求的就是 $pos$。可以发现从左到右，$pos$ 的变化为，对于一个 $p_i$，把所有 $\geq p_i$ 的 $pos$ 加一，可以从左到右扫描序列，用一个平衡树随便维护。

# [Day 13](http://oj.daimayuan.top/contest/312)

菜就多练。

### [T1](http://oj.daimayuan.top/contest/312/problem/2981)

暴力状压子树点集，并记录根，每次向上合并即可。

### [T2](http://oj.daimayuan.top/contest/312/problem/2983)

从后向前状压，看成加入一个体积为 $2^i$ 的，并让 $m$ 加一。会影响的只有最后 $\log$ 个位置或者一次大的进位。记录加一次数和上一位剩余值，分类讨论即可。

### [T3](http://oj.daimayuan.top/contest/312/problem/2982)

对于 $maxa\leq 10^12$ 的部分，可以分解质因数并给每个质因数随机赋权做 hash。

但是值域非常非常大。考虑如果能有一个集合 $S=\{x_1,x_2\dots x_k\}$，满足 $\forall i\not= j,(x_i,x_j)=1$，并且每个数都可以表示成若干个 $x$ 的乘积，那也是可行的。

考虑如何构造 $S$，增量构造，维护一个队列，每次取出队头 $x$，对于所有 $y\in S,(x,y)\not=1$，令 $d=(x,y)$，从 $S$ 中删除 $y$，加入 $\frac{y}{d}$ 和 $\frac{x}{d}$，并在队列中加入 $d$。因为每加入一个数，所有数的乘积至少除 $2$，初始乘积是 $V^n$，所以最多有 $n\log V$ 个数。依然随机赋权哈希，

# [Day 14](http://oj.daimayuan.top/contest/314)

喜欢保龄。

### [T1](http://oj.daimayuan.top/contest/314/problem/2985)

显然是从后向前做，不断合并联通块。中间的情况一定是一堆 SCC 形成了一条链，边被删去之后他可以反向，大多数情况较好维护，只需要把这个边跨过的所有点缩起来即可。但是一种情况不好做：那就是这个边连接了 $(i,i+1)$ 这两个 SCC，并且这两个 SCC 的大小都是 $1$。那此时他们两个其实是不应该缩起来的，这种情况以后处理。

但是初始是不好做的。注意到一个点 $i$ 如果有至少两个点不与他相邻，那 $i$ 和不与他相邻的所有点都要缩在一起。那先把所有之间没有连边的点缩起来，缩的大部分是对的。但是有一种情况：两个点的度数都是 $n-2$，并且他们初始不在一个 SCC 里面，并且他们之间没有可达性关系。这样他俩是不应该缩起来的。但是我们仍然可以先把他们先用并查集缩起来，然后跑一遍 tarjan。如果跑出来的结果是他俩自成一个 SCC，那暂时还是把他们看成两个点。否则他俩本来就可以缩起来，令答案减一。这个和第一段中不好处理的情况是一样做的。如果暂时还没有真正答案减一的话，那定义一个顶标，把并查集的根的权值设成 $1$。如果一旦对他进行任何操作（连接到他的边翻转或是加入别的 SCC），那就可以令答案加一。

### [T2](http://oj.daimayuan.top/contest/314/problem/2984)

不知道。

维护 $f_{i}$ 表示 $i$ 是 $1$ 的概率，每次转移是修改 $x$ 和 $fa_x$ 两个点。

这个东西在树上是对的，因为断开之后两边就互不影响了。但是环上有问题：他们是不独立的。但是这个只有断环边的时候会有影响，所以暴力枚举断的第一条环边的两端的状态即可。复杂度 $\mathcal O(n)$。

### [T3](http://oj.daimayuan.top/contest/314/problem/2986)

考虑 $k=0$。要求是对于所有 $i$，前 $2i-1$ 个至少选了 $i$ 个左括号。那堆维护一下即可。

考虑 $k$ 增加 $1$ 的时候，可以调整法证明，要么是括号不变，选一个位置干掉，或者是一对 () 变成了 )(，或者是一对 )( 变成了 ()，并且把他们两个之一的权值清零。

)( 变 () 没有任何条件，线段树维护分治信息即可。左括号看成加一，右括号看成减一，而 () 变 )( 需要满足，( 和 ) 之间没有出现 $0$，看成没有出现区间最小值，可以维护一万种信息。

# [Day 16](http://oj.daimayuan.top/contest/316)

### [T1](http://oj.daimayuan.top/contest/316/problem/2992)

二分答案。$k$ 是假的，选择点集不做贡献合法的充要条件是其是一个独立集。线段树优化 DP 即可。

### [T2](http://oj.daimayuan.top/contest/316/problem/2991)

首先枚举 $j-i+1$。定义一个位置 $i$ 不合法当且仅当 $s_i\not=s_{i-len}$。考虑两个相邻的不合法位置 $i<j,j-i<len$，其限制是，若 $l\leq i,r\geq j$ 并且 $r\bmod len$ 在 $[j,i]$ 区间里（注意是 $j,i$），则选取区间 $l,r$ 不合法。

但是一个 $len$ 来说，不合法的位置可能非常的多。但是考虑三个相邻的不合法位置 $i<j<k$，若 $k-i<len$，可以发现如果 $l\leq i,r\geq j$ 那一定全都不合法。

所以考虑把序列按照 $len$ 定长分块，每个块保留前三个和后三个不合法位置即可。每两个不合法位置是做一个区间覆盖，线段树维护区间覆盖，全局和，复杂度 $\mathcal O(n\log^2 n)$。

### [T3](http://oj.daimayuan.top/contest/316/problem/2993)

#### PN 筛

求 $\sum_{i=n}^N F(n)$。令 $F=G\circ H$。

$$
\sum_{i=n}^N F(n)=\sum_{d\leq N}G(d)SH(\lfloor \frac{N}{d}\rfloor)
$$

构造一个 $G$ 满足其在 $n$ 存在一次项的质因子时值为 $0$，$H$ 满足其前缀和 $SH$ 可以简单计算，就可以在 $\mathcal O(\sqrt N)$ 的时间内求得 $F$ 的前缀和。

回到原题。题目中定义的 $f(n)$ 不是积性函数。怎么办呢。考虑构造 $g(n)=y^{f(n)}$，这样 $g$ 是积性函数。下文的 $f$ 代指此处的 $g$。

考虑列出 $f$ 的贝尔级数：$F_p(x)=1+x+yx^2+yx^3+\dots=1+x+\frac{yx^2}{1-x}$。构造 $H_p(x)=\frac{1}{1-x}$，可以求得 $G_p(x)=1+(y-1)x^2$，满足一次项系数是 $0$ 的条件。这样可以得到：

$$
\sum_{n=1}^N f(n)=\sum_{d\leq N,d\; \text {is square free}}(y-1)^{\omega(d)}\lfloor\frac{N}{d^2}\rfloor
$$

若最后求得一个关于 $y$ 的多项式 $a_0+a_1y+a_2y^2\dots$，答案即为 $\sum_{i}a_ii^A$。然后考虑把这个东西带进去。

$$
\sum_{\substack{d\leq N,\\ d\;\text {is square free}}}\sum_{i=0}^{\omega(d)}\binom {\omega(d)} i (-1)^{\omega(d)-i} i^A\lfloor\frac{N}{d^2}\rfloor
$$

这样一个 $d$ 的贡献显然是只和 $\omega(d)$ 有关，线性筛预处理 $\omega(d)$，这样就能做到 $\mathcal O(n^{\frac 3 4})$。

考虑枚举 $d$ 之后做一个整除分块状物，复杂度就变成了 $\sum_{d}\sqrt{\frac{n}{d^2}}=\mathcal O(\sqrt n\log n)$。

# [Day 17](http://oj.daimayuan.top/contest/317)

### [T1](http://oj.daimayuan.top/contest/317/problem/2994)

嘻嘻。

假设区间 $[l,r]$ 内 $x$ 赢了，则 $[l,x]$ 和 $[x,r]$ 独立。所以只需要设 $f_{l,r,0/1}$ 表示区间 $[l,r]$，左或者右端点是赢家的概率。转移可以优化到 $\mathcal O(n)$。

### [T2](http://oj.daimayuan.top/contest/317/problem/2997)

首先对 $L,R$ 进行一个修：$l_{i+1}=\max(l_{i+1},l_i)$，$r_{i}=\min(r_i,r_{i+1})$ 等。然后贪心显然就是对的：维护一个变量，从左到右扫过去，脱离限制了就花费 $1$ 的代价修回来。

设进入这个区间时的前缀和是 $s$，可以归纳证明存在一个区间 $[l,r]$，使得 $s<l$ 是出去的是 $l$ 同时代价是一个递减 $1$ 的函数，$[l,r]$ 之间进来的 $s$ 出去还是 $s$，代价是一个常数，$>r$ 的 $s$ 出去之后是 $r$，代价是一个递增 $1$ 的函数。所以只需要线段树维护这三段即可。复杂度 $\mathcal O(n\log n)$。

### [T3](http://oj.daimayuan.top/contest/317/problem/2998)

好像有点难。假设 $x,y$ 是恶魔，那所有和 $x,y$ 均无交的区间会返回 $0$，那就可以把他们删掉。

然后剩下的区间都是 $1$。分两种情况讨论：

#### case 1

所有区间都包含 $x$，$y$ 需要满足删掉所有 $0$ 区间后，只剩下了 $y$ 这一个位置。这个是比较好做的。只需要做一个扫描线区间覆盖即可。

#### case 2

$x$ 和 $y$ 同时被单独的区间覆盖。考虑 $x$ 左边第一个没有被 $0$ 区间覆盖的元素 $l_x$ 和右边第一个没有被 $0$ 区间覆盖的元素 $r_x$。则对于 $l_x$，要求存在一个 $1$ 区间满足覆盖了 $x$ 且没有覆盖 $l_x$，也就是存在区间 $[l,r]$ 满足 $l\in[l_x+1,x],r\geq x$。对于 $r_x$ 也同理，需要存在区间 $[l,r]$ 满足 $l\leq x,r\in[x,r_x-1]$。

对于第一个限制比较好做，就是要找到 $[l_x+1,x]$ 内，右端点大于等于 $x$ 的最小值 $p$，需要 $y>p$，求 $p$ 可以用一个双指针配合堆实现。

对于第二个限制，找到左端点小于等于 $x$，右端点大于等于 $x$ 的最小值 $p$，则要求 $[x+1,p]$ 全部需要被覆盖。这个也是好做的，从右向左扫，求出每个点 $g_i$ 表示只考虑了左端点大于 $x$ 的区间，要覆盖点 $i$，需要的区间右端点最小是多少，则就是需要 $y>g_i$。

# [Day 18](http://oj.daimayuan.top/contest/318)

### [T1](http://oj.daimayuan.top/contest/318/problem/2999)

随机非常没有水平，因为随机排列前缀最大值个数是 $\mathcal O(\log n)$ 的，所以拐弯次数不会很多，暴力找出来判一下就行了。

### [T2](http://oj.daimayuan.top/contest/318/problem/3000)

考虑单组询问，建出来后缀树，做一个 DP。$f_i$ 表示 $i$ 子树内选了至少一个的方案数，转移比较简单，是一个关于子树的背包。

然后套上动态 DP 就行了。每一次是激活一条根链上的所有点。不想写了。

### [T3](http://oj.daimayuan.top/contest/319/problem/3004)

限制是前 $i$ 个里面最多选 $\lceil \frac i 2\rceil$，一个贪心是从前向后扫，维护小根堆，加两个数弹一个数。

是拆贡献，枚举一个 $v$，算最后答案中 $\geq v$ 的数的个数和。把 $\geq v$ 的数看成 $1$，$<v$ 的数看成 $0$。

假设有 $s$ 个 $1$，则看成初始在 $(0,0)$，如果出现一个 $1$ 看成往上走一步，出现一个 $0$ 看成往右走一步，最后走到 $(n-s,s)$。

考虑钦定多少个数不被浪费。如果钦定行走过程始终不接触 $y=x+2$ 则最后剩下 $s$ 个的才有贡献，如果不接触 $y=x+4$ 则是最后剩下 $s,s-1$ 个的有贡献，依此类推，只需要对于每个 $j=2,4,6\dots 2s$ 计算从 $(0,0)$ 走到 $(n-s,s)$ 并且不经过 $y=x+j$ 的路径数求和。

首先若 $s\geq n-s+j$ 则无解，根据下界的取值把 $s$ 分成 $1\sim \frac n 2$ 和 $\frac n 2+1\sim n$ 分类讨论，路径数计数是一个简单的反射容斥，需要计算组合数隔一个算一个的前缀和，可以简单预处理解决。

这样对于排序好的序列 $b$，答案就是 $\prod sum_i(i-1)!(n-i+1)!(b_i-b_{i-1})$。修改一个位置只会修改最多 $10$ 个差分值，暴力即可。

# [Day 19](http://oj.daimayuan.top/contest/319)

### [T1](http://oj.daimayuan.top/contest/319/problem/3002)

感觉挺有水平的。考虑 $l=n$ 怎么做：先确定 $y$ 之间的大小关系，然后每一行就有 $n+1$ 种选择，答案是 $n!(n+1)^n$...吗。并不是。因为如果两列一模一样，会在两种钦定大小方案里面算重。所以考虑钦定等价类，一个等价类内部的 $y$ 全部相等来做容斥。

设 $f_i$ 表示大小为 $i$ 的等价类的容斥系数，先令 $g_i=\frac{f_i}{i!}$，常规的 exp 就是 $\sum_{i\geq 1}\frac{G^i}{i!}$，但是如果一个真实的相等 $y$ 段划分成了 $i$ 个等价类会乘一个 $i!$ 的系数，所以其实是 $\sum_{i\geq 1}G^i=\frac{1}{1-G}-1$。因为要求最终每个段的贡献系数是 $1$ 而这里是指数生成函数，所以 $\frac{1}{1-G}-1=e^x-1$，可以解得 $G=1-e^{-x}$，即集合 $S$ 的容斥系数是 $(-1)^{\lvert S\rvert+1}$，所以如果划分成了 $i$ 个等价类，最终的容斥系数是 $(-1)^{n-i}$。

把 $l$ 从大到小排序，这样在矩形的左上方形成了一个阶梯状的有效区域。扫轮廓，如果往右走一条边就是新加入一个列，可以选择加入之前的集合，也可以新建一个。如果往上走，就乘一个集合个数加一。复杂度是 $\mathcal O(n^2)$。

啊我草这玩意能不能优化啊！

### [T2](http://oj.daimayuan.top/contest/319/problem/3003)

对于 $k$ 是奇数的情况，$x$ 的最低位不可能变成 $0$，所以会一直跳。那考虑他的起点，即一个最小的值满足从这个值开始跳能跳到 $x$，这个可以通过预处理 $pre$ 的倍增数组实现，查询就可以直接查了。

对于 $k$ 不一定是奇数，可以暴力跳 $x$ 使其不断乘 $2$，直到最低位的 $2$ 的次幂大于等于 $k$ 中 $2$ 的次幂时，上述结论就仍然成立了。

### [T3](http://oj.daimayuan.top/contest/319/problem/3004)

考虑不断划分等价类。初始 $c$ 相同的为一个等价类，设 $i$ 所处等价类编号为 $d_i$，每次操作是要求 $d_{a_i}=d_{a_j},d_{b_i}=d_{b_j},c_i=c_j$ 这三个条件同时满足，$i,j$ 才仍然在同一个等价类内，否则 $i,j$ 会分裂开。

考虑快速的维护上述过程。当一个等价类 $S$ 分裂成 $S_1,S_2\dots S_k$ 的时候，我们可以以 $\lvert S_i\rvert$ 的代价操作所有**集合大小不是最大**的 $S_i$，可以证明这样启发式分裂的操作次数是 $\mathcal O(n\log n)$ 的。

把等价类内部的所有点排成一个顺序任意的链，然后把上次操作分裂出来的所有等价类中的点 $x$（上次操作中只有他们的 $d$ 改变了）。对于所有 $a_i=x$ 或 $b_i=x$，在 $i$ 所处的链上进行一个检查：检查其在链上的前驱点和后继点的 $d_{a_i}$ 和 $d_{b_i}$ 都是否相等，如果不相等就加入一个断点。最后找到所有有至少一个断点的等价类，把所有断点断开，把颜色相同的链再次合并即可。最后把分裂的结构建出来一个树，查询就是要查 LCA，复杂度可以做到 $\mathcal O(n\log n+q)$。